'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _sortBy2 = require('lodash/sortBy');

var _sortBy3 = _interopRequireDefault(_sortBy2);

var _groupBy2 = require('lodash/groupBy');

var _groupBy3 = _interopRequireDefault(_groupBy2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _reduce2 = require('lodash/reduce');

var _reduce3 = _interopRequireDefault(_reduce2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _d3Scale = require('d3-scale');

var _d3Cloud = require('d3-cloud');

var _d3Cloud2 = _interopRequireDefault(_d3Cloud);

var _colorFunc = require('./helpers/colorFunc');

var _colorFunc2 = _interopRequireDefault(_colorFunc);

var _value = require('./helpers/value');

var _value2 = _interopRequireDefault(_value);

var _propTypes3 = require('./helpers/propTypes');

var _propTypes4 = _interopRequireDefault(_propTypes3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Renders cloud of tags/keywords. Uses [d3-cloud](https://www.npmjs.com/package/d3-cloud) for calculations.
 * Please notice, `series` data points should have `label` attribute. See example below.
 *
 * @example ../docs/examples/Cloud.md
 */
var Cloud = function (_Component) {
    _inherits(Cloud, _Component);

    function Cloud(props) {
        _classCallCheck(this, Cloud);

        var _this = _possibleConstructorReturn(this, (Cloud.__proto__ || Object.getPrototypeOf(Cloud)).call(this, props));

        _this.buildCloud = _this.buildCloud.bind(_this);

        _this.state = {
            labels: [],
            series: []
        };
        return _this;
    }

    // helpers

    _createClass(Cloud, [{
        key: 'buildCloud',
        value: function buildCloud(props) {
            var layerWidth = props.layerWidth,
                layerHeight = props.layerHeight,
                series = props.series;
            var font = props.font,
                fontStyle = props.fontStyle,
                fontWeight = props.fontWeight,
                rotate = props.rotate,
                spiral = props.spiral,
                padding = props.padding,
                random = props.random;


            var scale = (0, _d3Scale.scaleLinear)().range([props.minFontSize, props.maxFontSize]).domain([props.minY, props.maxY]);

            var words = (0, _reduce3.default)(series, function (words, _ref, seriesIndex) {
                var data = _ref.data;

                (0, _forEach3.default)(data, function (point, pointIndex) {
                    words.push((0, _defaults3.default)({
                        text: point.label,
                        size: point.y,
                        seriesIndex: seriesIndex,
                        pointIndex: pointIndex
                    }, point));
                });
                return words;
            }, []);

            (0, _d3Cloud2.default)().size([layerWidth, layerHeight]).words(words).font(font).fontStyle(fontStyle).fontWeight(fontWeight).rotate(rotate).spiral(spiral).padding(padding).random(random).timeInterval(15).fontSize(function (d) {
                return scale(d.size);
            }).on('end', function (series, labels) {
                labels = (0, _map3.default)((0, _groupBy3.default)(labels, 'seriesIndex'), function (labels) {
                    return (0, _sortBy3.default)(labels, 'pointIndex');
                });
                this.setState({ series: series, labels: labels });
            }.bind(this, series)).start();
        }

        // lifecycle

    }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
            try {
                this.buildCloud(this.props);
            } catch (e) {
                console.warn(e);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            try {
                this.buildCloud(nextProps);
            } catch (e) {
                console.warn(e);
            }
        }

        // render

    }, {
        key: 'render',
        value: function render() {
            var props = this.props,
                state = this.state;
            var className = props.className,
                style = props.style,
                layerWidth = props.layerWidth,
                layerHeight = props.layerHeight,
                opacity = props.opacity;
            var labels = state.labels;


            var color = (0, _colorFunc2.default)(props.colors);

            return _react2.default.createElement(
                'g',
                {
                    className: className, style: style, opacity: opacity,
                    transform: 'translate(' + layerWidth / 2 + ',' + layerHeight / 2 + ')' },
                (0, _map3.default)(state.series, function (series, seriesIndex) {
                    var seriesVisible = props.seriesVisible,
                        seriesStyle = props.seriesStyle,
                        seriesAttributes = props.seriesAttributes;


                    seriesVisible = (0, _value2.default)(seriesVisible, { seriesIndex: seriesIndex, series: series, props: props });
                    if (!seriesVisible) {
                        return;
                    }

                    seriesAttributes = (0, _value2.default)(seriesAttributes, { seriesIndex: seriesIndex, series: series, props: props });
                    seriesStyle = (0, _value2.default)(seriesStyle, { seriesIndex: seriesIndex, series: series, props: props });

                    return _react2.default.createElement(
                        'g',
                        _extends({
                            key: seriesIndex,
                            className: className && className + '-series ' + className + '-series-' + seriesIndex,
                            style: seriesStyle,
                            opacity: series.opacity
                        }, seriesAttributes),
                        (0, _map3.default)(series.data, function (point, pointIndex) {
                            var labelVisible = props.labelVisible,
                                labelAttributes = props.labelAttributes,
                                labelStyle = props.labelStyle;

                            var label = labels[seriesIndex] && labels[seriesIndex][pointIndex];
                            if (!label) {
                                return;
                            }

                            labelVisible = (0, _value2.default)(labelVisible, {
                                seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, label: label, series: series, props: props
                            });

                            if (!labelVisible) {
                                return;
                            }

                            labelAttributes = (0, _value2.default)(labelAttributes, {
                                seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, label: label, series: series, props: props
                            });
                            labelStyle = (0, _value2.default)([point.style, series.style, labelStyle], { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, label: label, series: series, props: props });

                            return _react2.default.createElement(
                                'g',
                                {
                                    key: pointIndex,
                                    className: className && className + '-label ' + className + '-label-' + +pointIndex,
                                    style: {
                                        fontSize: label.size + 'px',
                                        fontFamily: label.font
                                    } },
                                _react2.default.createElement(
                                    'text',
                                    _extends({
                                        transform: 'translate(' + label.x + ',' + label.y + '),rotate(' + label.rotate + ')',
                                        fill: point.color || series.color || color(seriesIndex),
                                        fillOpacity: point.opacity,
                                        textAnchor: 'middle',
                                        style: labelStyle
                                    }, labelAttributes),
                                    label.text
                                )
                            );
                        })
                    );
                })
            );
        }
    }]);

    return Cloud;
}(_react.Component);

exports.default = Cloud;


Cloud.displayName = 'Cloud';

Cloud.propTypes = {
    className: _propTypes2.default.string,
    colors: _propTypes2.default.oneOfType([_propTypes2.default.oneOf(['category10', 'category20', 'category20b', 'category20c']), _propTypes2.default.arrayOf(_propTypes2.default.string), _propTypes2.default.func]),
    opacity: _propTypes2.default.number,
    style: _propTypes2.default.object,

    font: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    minFontSize: _propTypes2.default.number,
    maxFontSize: _propTypes2.default.number,
    fontStyle: _propTypes2.default.oneOfType([_propTypes2.default.oneOf(['normal', 'italic', 'oblique', 'inherit']), _propTypes2.default.func]),
    fontWeight: _propTypes2.default.oneOfType([_propTypes2.default.oneOf(['normal', 'bold', 'bolder', 'lighter', 'normal', '100', '200', '300', '400', '500', '600', '700', '800', '900']), _propTypes2.default.func]),
    /**
     * Angle in degrees
     */
    rotate: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func]),
    /**
     * Type of spiral used for positioning words. This can either be one of the two
     * built-in spirals, "archimedean" and "rectangular", or an arbitrary spiral
     * generator can be used, of the following form
     */
    spiral: _propTypes2.default.oneOfType([_propTypes2.default.oneOf(['archimedean', 'rectangular']), _propTypes2.default.func]),
    padding: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func]),
    random: _propTypes2.default.func,

    label: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    labelFormat: _propTypes2.default.func,

    labelVisible: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    labelAttributes: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    labelStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),

    seriesVisible: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    seriesAttributes: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    seriesStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),

    layerWidth: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    layerHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    seriesIndex: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.array, _propTypes2.default.func]),
    series: _propTypes4.default.series,
    minX: _propTypes2.default.number,
    maxX: _propTypes2.default.number,
    minY: _propTypes2.default.number,
    maxY: _propTypes2.default.number
};

Cloud.defaultProps = {
    colors: 'category20',
    seriesVisible: true,
    labelVisible: true,

    font: 'serif',
    minFontSize: 10,
    maxFontSize: 100,
    fontStyle: 'normal',
    fontWeight: 'normal',
    rotate: 0,
    spiral: 'archimedean',
    padding: 1,
    random: Math.random
};